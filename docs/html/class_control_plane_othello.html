<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TinyCR: ControlPlaneOthello&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TinyCR
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_control_plane_othello-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ControlPlaneOthello&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="control__plane__othello_8h_source.html">control_plane_othello.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3d9785a6e7a62d535470e579e13a93a0"><td class="memItemLeft" align="right" valign="top"><a id="a3d9785a6e7a62d535470e579e13a93a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setSeed</b> (int seed)</td></tr>
<tr class="separator:a3d9785a6e7a62d535470e579e13a93a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7a169a39306706c376694b47bcc819"><td class="memItemLeft" align="right" valign="top"><a id="a5a7a169a39306706c376694b47bcc819"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>changeSeed</b> ()</td></tr>
<tr class="separator:a5a7a169a39306706c376694b47bcc819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aad907bcc21223ba180a111354fa901"><td class="memItemLeft" align="right" valign="top"><a id="a1aad907bcc21223ba180a111354fa901"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>multiply_high_u32</b> (uint32_t x, uint32_t y) const</td></tr>
<tr class="separator:a1aad907bcc21223ba180a111354fa901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4276eef4468ae10131abd7c5fac382c"><td class="memItemLeft" align="right" valign="top"><a id="ae4276eef4468ae10131abd7c5fac382c"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>fast_map_to_A</b> (uint32_t x) const</td></tr>
<tr class="separator:ae4276eef4468ae10131abd7c5fac382c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc629610c971eb1fa8c0cdcc3b854d9"><td class="memItemLeft" align="right" valign="top"><a id="a1dc629610c971eb1fa8c0cdcc3b854d9"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>fast_map_to_B</b> (uint32_t x) const</td></tr>
<tr class="separator:a1dc629610c971eb1fa8c0cdcc3b854d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b609c0bfae957af25237cbcab3cf1bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#a4b609c0bfae957af25237cbcab3cf1bf">getIndices</a> (const K &amp;k, uint32_t &amp;aInd, uint32_t &amp;bInd) const</td></tr>
<tr class="separator:a4b609c0bfae957af25237cbcab3cf1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec591e48d4d2bae9408fb5f11736320"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#adec591e48d4d2bae9408fb5f11736320">memResize</a> ()</td></tr>
<tr class="separator:adec591e48d4d2bae9408fb5f11736320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9bf4ab36c087072d6546db2d796a5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#aea9bf4ab36c087072d6546db2d796a5a">memSet</a> (uint32_t index, uint64_t value)</td></tr>
<tr class="separator:aea9bf4ab36c087072d6546db2d796a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492f6423114cf3eac94c9e7c58c1f6f5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#a492f6423114cf3eac94c9e7c58c1f6f5">memGet</a> (uint32_t index) const</td></tr>
<tr class="separator:a492f6423114cf3eac94c9e7c58c1f6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee6230a09e260896e4d0f6d829f16e5"><td class="memItemLeft" align="right" valign="top"><a id="a4ee6230a09e260896e4d0f6d829f16e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>memValueSet</b> (uint32_t index, uint64_t value)</td></tr>
<tr class="separator:a4ee6230a09e260896e4d0f6d829f16e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663526156d1d01a008e0446fcdd7fbd4"><td class="memItemLeft" align="right" valign="top"><a id="a663526156d1d01a008e0446fcdd7fbd4"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>memValueGet</b> (uint32_t index) const</td></tr>
<tr class="separator:a663526156d1d01a008e0446fcdd7fbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e140f2f73de673b5f55a3df645dda0f"><td class="memItemLeft" align="right" valign="top"><a id="a8e140f2f73de673b5f55a3df645dda0f"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>getMa</b> () const</td></tr>
<tr class="separator:a8e140f2f73de673b5f55a3df645dda0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83bd41d95f969fede47417d2b9270cef"><td class="memItemLeft" align="right" valign="top"><a id="a83bd41d95f969fede47417d2b9270cef"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>getMb</b> () const</td></tr>
<tr class="separator:a83bd41d95f969fede47417d2b9270cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bdf0a1f098dbef506fc692f1c69137"><td class="memItemLeft" align="right" valign="top"><a id="a05bdf0a1f098dbef506fc692f1c69137"></a>
Hasher64&lt; K &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getH</b> () const</td></tr>
<tr class="separator:a05bdf0a1f098dbef506fc692f1c69137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dcc4beb15e3797e554e71e89499e2b"><td class="memItemLeft" align="right" valign="top"><a id="a78dcc4beb15e3797e554e71e89499e2b"></a>
Hasher32&lt; K &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getHd</b> () const</td></tr>
<tr class="separator:a78dcc4beb15e3797e554e71e89499e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7383a313da57dda4bb7ead9a46cc40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#aaa7383a313da57dda4bb7ead9a46cc40">query</a> (const K &amp;k, V &amp;out) const</td></tr>
<tr class="separator:aaa7383a313da57dda4bb7ead9a46cc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9921044972fefc691e07cbf34eab7bba"><td class="memItemLeft" align="right" valign="top"><a id="a9921044972fefc691e07cbf34eab7bba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ControlPlaneOthello</b> (uint32_t keyCapacity=256, float o_ratio=1)</td></tr>
<tr class="separator:a9921044972fefc691e07cbf34eab7bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2e5da3c5dcd3fdaceb5653435ef105"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#a8b2e5da3c5dcd3fdaceb5653435ef105">resizeKey</a> (uint32_t targetCapacity, bool compact=false)</td></tr>
<tr class="separator:a8b2e5da3c5dcd3fdaceb5653435ef105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3fa7a0e3765a59e9c8d5814fc50502"><td class="memItemLeft" align="right" valign="top"><a id="a4a3fa7a0e3765a59e9c8d5814fc50502"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMinimalKeyCapacity</b> (uint32_t minimalKeyCapacity)</td></tr>
<tr class="separator:a4a3fa7a0e3765a59e9c8d5814fc50502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ccc157a371010904c9593a6c2a21d5"><td class="memItemLeft" align="right" valign="top"><a id="a41ccc157a371010904c9593a6c2a21d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a41ccc157a371010904c9593a6c2a21d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0534d0205629ca9acf100496a2e008"><td class="memItemLeft" align="right" valign="top"><a id="a4d0534d0205629ca9acf100496a2e008"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compose</b> (const unordered_map&lt; V, V &gt; &amp;migration)</td></tr>
<tr class="separator:a4d0534d0205629ca9acf100496a2e008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af707b7dcf0fa824c6eb8d397cfa52570"><td class="memItemLeft" align="right" valign="top"><a id="af707b7dcf0fa824c6eb8d397cfa52570"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prepareDP</b> ()</td></tr>
<tr class="separator:af707b7dcf0fa824c6eb8d397cfa52570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3305404618dcc7f8951b19289b7cd5f0"><td class="memItemLeft" align="right" valign="top"><a id="a3305404618dcc7f8951b19289b7cd5f0"></a>
V&#160;</td><td class="memItemRight" valign="bottom"><b>randVal</b> (int i=0) const</td></tr>
<tr class="separator:a3305404618dcc7f8951b19289b7cd5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f690001a8b0a88187b44309aae68bdd"><td class="memItemLeft" align="right" valign="top"><a id="a2f690001a8b0a88187b44309aae68bdd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#a2f690001a8b0a88187b44309aae68bdd">resetBuildState</a> ()</td></tr>
<tr class="memdesc:a2f690001a8b0a88187b44309aae68bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forget all previous build states and get prepared for a new build. <br /></td></tr>
<tr class="separator:a2f690001a8b0a88187b44309aae68bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90fc3b63bb599a7b6edab5f1753972a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#af90fc3b63bb599a7b6edab5f1753972a">addEdge</a> (uint32_t key, uint32_t ha, uint32_t hb)</td></tr>
<tr class="separator:af90fc3b63bb599a7b6edab5f1753972a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d494ff4312346693f1bc4fe16c05fd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#a7d494ff4312346693f1bc4fe16c05fd8">testHash</a> ()</td></tr>
<tr class="separator:a7d494ff4312346693f1bc4fe16c05fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4fcb321e1d4efedde64ff7c95f1ce5"><td class="memTemplParams" colspan="2">template&lt;bool fillValue, bool fillIndex, bool keepDigest = false&gt; </td></tr>
<tr class="memitem:adc4fcb321e1d4efedde64ff7c95f1ce5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#adc4fcb321e1d4efedde64ff7c95f1ce5">fillTreeDFS</a> (uint32_t root)</td></tr>
<tr class="separator:adc4fcb321e1d4efedde64ff7c95f1ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a21434f8c549aa202bc917e1f9c4e7"><td class="memTemplParams" colspan="2"><a id="ae6a21434f8c549aa202bc917e1f9c4e7"></a>
template&lt;bool fillValue, bool fillIndex, bool keepDigest = false&gt; </td></tr>
<tr class="memitem:ae6a21434f8c549aa202bc917e1f9c4e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fillSingle</b> (uint32_t keyId, uint32_t nodeToFill, uint32_t oppositeNode)</td></tr>
<tr class="separator:ae6a21434f8c549aa202bc917e1f9c4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab2413a6ac439467063026c5859d7cd"><td class="memTemplParams" colspan="2">template&lt;bool fillValue, bool fillIndex, bool keepDigest = false&gt; </td></tr>
<tr class="memitem:a6ab2413a6ac439467063026c5859d7cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#a6ab2413a6ac439467063026c5859d7cd">fixSingle</a> (uint32_t nodeToFix, uint64_t x, uint32_t ix)</td></tr>
<tr class="separator:a6ab2413a6ac439467063026c5859d7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b988d0c4624715d39a6f8fd7ec163d"><td class="memTemplParams" colspan="2">template&lt;bool fillValue, bool fillIndex, bool keepDigest = false&gt; </td></tr>
<tr class="memitem:aa2b988d0c4624715d39a6f8fd7ec163d"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#aa2b988d0c4624715d39a6f8fd7ec163d">fixHalfTreeDFS</a> (uint32_t keyId, uint32_t root, uint32_t hb)</td></tr>
<tr class="separator:aa2b988d0c4624715d39a6f8fd7ec163d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80d382c8c787597114cccb946b18e2c"><td class="memTemplParams" colspan="2"><a id="ac80d382c8c787597114cccb946b18e2c"></a>
template&lt;bool fillValue, bool fillIndex, bool keepDigest = false&gt; </td></tr>
<tr class="memitem:ac80d382c8c787597114cccb946b18e2c"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fixHalfTreeDFS_on_demand</b> (uint32_t keyId, uint32_t root, uint32_t hb, vector&lt; uint32_t &gt; &amp;flipped_index)</td></tr>
<tr class="separator:ac80d382c8c787597114cccb946b18e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c7319adef8cd9b2bdd8fb10241a81d"><td class="memItemLeft" align="right" valign="top"><a id="a59c7319adef8cd9b2bdd8fb10241a81d"></a>
vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getConnectedComponent</b> (uint32_t skip, uint32_t root)</td></tr>
<tr class="separator:a59c7319adef8cd9b2bdd8fb10241a81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff99f09fe9c7eba6dc8a3ebc6a5294cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#aff99f09fe9c7eba6dc8a3ebc6a5294cd">isConnectedDFS</a> (uint32_t ha0, uint32_t hb0)</td></tr>
<tr class="separator:aff99f09fe9c7eba6dc8a3ebc6a5294cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cd82573a97b86005611adbe55e07da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#a58cd82573a97b86005611adbe55e07da">connectBFS</a> (uint32_t root)</td></tr>
<tr class="separator:a58cd82573a97b86005611adbe55e07da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2d4eacc2f67e0325cf938d69c32621"><td class="memItemLeft" align="right" valign="top"><a id="a0d2d4eacc2f67e0325cf938d69c32621"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>connectBFS_on_demand</b> (uint32_t root, vector&lt; uint32_t &gt; &amp;flipped_index)</td></tr>
<tr class="separator:a0d2d4eacc2f67e0325cf938d69c32621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59f02d3a8f74a3dab8c5dd163216c63"><td class="memTemplParams" colspan="2">template&lt;bool keepDigest = false&gt; </td></tr>
<tr class="memitem:af59f02d3a8f74a3dab8c5dd163216c63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#af59f02d3a8f74a3dab8c5dd163216c63">fillValue</a> ()</td></tr>
<tr class="separator:af59f02d3a8f74a3dab8c5dd163216c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95906a3bf53de4d81221dbd44edc059"><td class="memItemLeft" align="right" valign="top"><a id="ab95906a3bf53de4d81221dbd44edc059"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fillOnlyValue</b> ()</td></tr>
<tr class="separator:ab95906a3bf53de4d81221dbd44edc059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8947acec7f8a3e4d5e259a88297f3da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#af8947acec7f8a3e4d5e259a88297f3da">tryBuild</a> ()</td></tr>
<tr class="separator:af8947acec7f8a3e4d5e259a88297f3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9afb6bba6c1b6ad17fdb53577bf4f0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#ab9afb6bba6c1b6ad17fdb53577bf4f0b">build</a> ()</td></tr>
<tr class="separator:ab9afb6bba6c1b6ad17fdb53577bf4f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb814a60b551f256f86f6aca894cd924"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#aeb814a60b551f256f86f6aca894cd924">queryIndex</a> (const K &amp;k) const</td></tr>
<tr class="separator:aeb814a60b551f256f86f6aca894cd924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d4ef0f210e55783859a2429aa37278"><td class="memItemLeft" align="right" valign="top"><a id="a94d4ef0f210e55783859a2429aa37278"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>queryIndex</b> (const K &amp;&amp;k) const</td></tr>
<tr class="separator:a94d4ef0f210e55783859a2429aa37278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d64d2d2eca2d83013231799a9ffe8f5"><td class="memItemLeft" align="right" valign="top"><a id="a7d64d2d2eca2d83013231799a9ffe8f5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isEmpty</b> (int index)</td></tr>
<tr class="separator:a7d64d2d2eca2d83013231799a9ffe8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d8bfd7bf8ab2e13baf7986dc6a4769"><td class="memTemplParams" colspan="2">template&lt;bool DoNotRebuild = false&gt; </td></tr>
<tr class="memitem:a88d8bfd7bf8ab2e13baf7986dc6a4769"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#a88d8bfd7bf8ab2e13baf7986dc6a4769">insert</a> (pair&lt; K, V &gt; &amp;&amp;kv)</td></tr>
<tr class="separator:a88d8bfd7bf8ab2e13baf7986dc6a4769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48876fb27b668f113626fb5462d8b2a9"><td class="memItemLeft" align="right" valign="top"><a id="a48876fb27b668f113626fb5462d8b2a9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>insert_on_demand</b> (pair&lt; K, V &gt; kv, vector&lt; uint32_t &gt; &amp;flipped_index)</td></tr>
<tr class="separator:a48876fb27b668f113626fb5462d8b2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac284f72359848275e9eb096f63387de4"><td class="memItemLeft" align="right" valign="top"><a id="ac284f72359848275e9eb096f63387de4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>valueFlip</b> (pair&lt; K, V &gt; kv)</td></tr>
<tr class="separator:ac284f72359848275e9eb096f63387de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaccc45bae4325b9f447e3de300b399d3"><td class="memItemLeft" align="right" valign="top"><a id="aaccc45bae4325b9f447e3de300b399d3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>valueFlip_on_demand</b> (pair&lt; K, V &gt; kv, vector&lt; uint32_t &gt; &amp;flipped_index)</td></tr>
<tr class="separator:aaccc45bae4325b9f447e3de300b399d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6630b78c1477e02e02576b6dbfcf9a42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#a6630b78c1477e02e02576b6dbfcf9a42">eraseAt</a> (uint32_t keyId)</td></tr>
<tr class="separator:a6630b78c1477e02e02576b6dbfcf9a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cbb98f7d0c741e91f49e19fb2f6a3e"><td class="memItemLeft" align="right" valign="top"><a id="a57cbb98f7d0c741e91f49e19fb2f6a3e"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>updateMapping</b> (const K &amp;k, V &amp;val)</td></tr>
<tr class="separator:a57cbb98f7d0c741e91f49e19fb2f6a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f8cb78af02604097a15a5368732ca3"><td class="memItemLeft" align="right" valign="top"><a id="a30f8cb78af02604097a15a5368732ca3"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>updateMapping</b> (const K &amp;&amp;k, V &amp;&amp;val)</td></tr>
<tr class="separator:a30f8cb78af02604097a15a5368732ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2042d9803c4111aebdfc689e730b641e"><td class="memItemLeft" align="right" valign="top"><a id="a2042d9803c4111aebdfc689e730b641e"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>updateValueAt</b> (uint32_t keyId, V val)</td></tr>
<tr class="separator:a2042d9803c4111aebdfc689e730b641e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26c32223bf70b76ef02551652009c08"><td class="memItemLeft" align="right" valign="top"><a id="ac26c32223bf70b76ef02551652009c08"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>updateValueAt_on_demand</b> (uint32_t keyId, V val, vector&lt; uint32_t &gt; &amp;flipped_index)</td></tr>
<tr class="separator:ac26c32223bf70b76ef02551652009c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35442d22f6b7ba3845b327826249b101"><td class="memItemLeft" align="right" valign="top"><a id="a35442d22f6b7ba3845b327826249b101"></a>
const vector&lt; K &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getKeys</b> () const</td></tr>
<tr class="separator:a35442d22f6b7ba3845b327826249b101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb72285ead76a24fe4d37086015e7d8"><td class="memItemLeft" align="right" valign="top"><a id="a1bb72285ead76a24fe4d37086015e7d8"></a>
const vector&lt; V &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getValues</b> () const</td></tr>
<tr class="separator:a1bb72285ead76a24fe4d37086015e7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb941b9e1ac187876f102e921a1f7e89"><td class="memItemLeft" align="right" valign="top"><a id="acb941b9e1ac187876f102e921a1f7e89"></a>
vector&lt; V &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getValues</b> ()</td></tr>
<tr class="separator:acb941b9e1ac187876f102e921a1f7e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c37996bf4e0b81deaad9f63bffd1eb7"><td class="memItemLeft" align="right" valign="top"><a id="a8c37996bf4e0b81deaad9f63bffd1eb7"></a>
const vector&lt; uint32_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getIndexMemory</b> () const</td></tr>
<tr class="separator:a8c37996bf4e0b81deaad9f63bffd1eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36701aa8b1f8c956ddd047aff2b54a4"><td class="memItemLeft" align="right" valign="top"><a id="ab36701aa8b1f8c956ddd047aff2b54a4"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:ab36701aa8b1f8c956ddd047aff2b54a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78540b42e692f6c6cc000e4b9c21097b"><td class="memItemLeft" align="right" valign="top"><a id="a78540b42e692f6c6cc000e4b9c21097b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isMember</b> (const K &amp;x) const</td></tr>
<tr class="separator:a78540b42e692f6c6cc000e4b9c21097b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad127acdb7c401a1b84545fae2a8ba08c"><td class="memItemLeft" align="right" valign="top"><a id="ad127acdb7c401a1b84545fae2a8ba08c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>erase_on_demand</b> (const K &amp;k, vector&lt; uint32_t &gt; &amp;flipped_index, uint32_t keyId=-1)</td></tr>
<tr class="separator:ad127acdb7c401a1b84545fae2a8ba08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b10dadfa83140b4e2d4196b6a72572a"><td class="memItemLeft" align="right" valign="top"><a id="a6b10dadfa83140b4e2d4196b6a72572a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (const K &amp;k, uint32_t keyId=-1)</td></tr>
<tr class="separator:a6b10dadfa83140b4e2d4196b6a72572a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2750f24eda910fa685508e442f9d36"><td class="memItemLeft" align="right" valign="top"><a id="a0f2750f24eda910fa685508e442f9d36"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>checkIntegrity</b> () const</td></tr>
<tr class="separator:a0f2750f24eda910fa685508e442f9d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b98af1336db4a9d0c1dfdd013c4357"><td class="memItemLeft" align="right" valign="top"><a id="a79b98af1336db4a9d0c1dfdd013c4357"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>reportDataPlaneMemUsage</b> () const</td></tr>
<tr class="separator:a79b98af1336db4a9d0c1dfdd013c4357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4098b05ea008c296c3de9fef5c0fc1"><td class="memItemLeft" align="right" valign="top"><a id="add4098b05ea008c296c3de9fef5c0fc1"></a>
vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getCnt</b> () const</td></tr>
<tr class="separator:add4098b05ea008c296c3de9fef5c0fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1346e66e73c39b85a6144aca84463a12"><td class="memItemLeft" align="right" valign="top"><a id="a1346e66e73c39b85a6144aca84463a12"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>outputMappedValues</b> (ofstream &amp;fout) const</td></tr>
<tr class="separator:a1346e66e73c39b85a6144aca84463a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ffc4433e5db2dd27764274577f21bb"><td class="memItemLeft" align="right" valign="top"><a id="aa9ffc4433e5db2dd27764274577f21bb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getStaticCnt</b> ()</td></tr>
<tr class="separator:aa9ffc4433e5db2dd27764274577f21bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acddfd1a05662c5313e28c45bc7d4a80e"><td class="memItemLeft" align="right" valign="top"><a id="acddfd1a05662c5313e28c45bc7d4a80e"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>getMemoryCost</b> () const</td></tr>
<tr class="separator:acddfd1a05662c5313e28c45bc7d4a80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aaf3405c4ccbb852b8a80a23d3013912f"><td class="memItemLeft" align="right" valign="top"><a id="aaf3405c4ccbb852b8a80a23d3013912f"></a>
vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mem</b> {}</td></tr>
<tr class="separator:aaf3405c4ccbb852b8a80a23d3013912f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00726b12a2a74d22818248311380c78d"><td class="memItemLeft" align="right" valign="top"><a id="a00726b12a2a74d22818248311380c78d"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>ma</b> = 0</td></tr>
<tr class="separator:a00726b12a2a74d22818248311380c78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c1092a188d24d51e6100a05535fcd9"><td class="memItemLeft" align="right" valign="top"><a id="a14c1092a188d24d51e6100a05535fcd9"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>mb</b> = 0</td></tr>
<tr class="separator:a14c1092a188d24d51e6100a05535fcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1164e122b07bd2dbc4cd87baa33c8a71"><td class="memItemLeft" align="right" valign="top"><a id="a1164e122b07bd2dbc4cd87baa33c8a71"></a>
Hasher64&lt; K &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hab</b> = Hasher64&lt;K&gt;((uint64_t(InputBase::rand()) &lt;&lt; 32) + InputBase::rand())</td></tr>
<tr class="separator:a1164e122b07bd2dbc4cd87baa33c8a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40cb9917674a431e53fd2b503a0c7c9"><td class="memItemLeft" align="right" valign="top"><a id="af40cb9917674a431e53fd2b503a0c7c9"></a>
Hasher32&lt; K &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hd</b> = Hasher32&lt;K&gt;(uint32_t(InputBase::rand()))</td></tr>
<tr class="separator:af40cb9917674a431e53fd2b503a0c7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8510cb612eb1ecad9f5f652de4da8f89"><td class="memItemLeft" align="right" valign="top"><a id="a8510cb612eb1ecad9f5f652de4da8f89"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>maintainingDP</b> = maintainDP</td></tr>
<tr class="separator:a8510cb612eb1ecad9f5f652de4da8f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8c0fc19979f97f53777a86dc047022"><td class="memItemLeft" align="right" valign="top"><a id="a0d8c0fc19979f97f53777a86dc047022"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>keyCnt</b> = 0</td></tr>
<tr class="separator:a0d8c0fc19979f97f53777a86dc047022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9f01637723be3eacb1a22b341555ee"><td class="memItemLeft" align="right" valign="top"><a id="acf9f01637723be3eacb1a22b341555ee"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>minimalKeyCapacity</b> = 0</td></tr>
<tr class="separator:acf9f01637723be3eacb1a22b341555ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b16024bb82bf1f9a1a686890c01114"><td class="memItemLeft" align="right" valign="top"><a id="a94b16024bb82bf1f9a1a686890c01114"></a>
vector&lt; K &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keys</b> {}</td></tr>
<tr class="separator:a94b16024bb82bf1f9a1a686890c01114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec89d45c4d471b4a52f735ce2f8a60cc"><td class="memItemLeft" align="right" valign="top"><a id="aec89d45c4d471b4a52f735ce2f8a60cc"></a>
vector&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>values</b> {}</td></tr>
<tr class="separator:aec89d45c4d471b4a52f735ce2f8a60cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dced1dbed55458a9b373820f044c55"><td class="memItemLeft" align="right" valign="top"><a id="af2dced1dbed55458a9b373820f044c55"></a>
vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>indMem</b> {}</td></tr>
<tr class="separator:af2dced1dbed55458a9b373820f044c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac66f2ed68a4352423a2d73f320a6c39"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="struct_othello_c_p_cell.html">OthelloCPCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#aac66f2ed68a4352423a2d73f320a6c39">head</a> {}</td></tr>
<tr class="memdesc:aac66f2ed68a4352423a2d73f320a6c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">subscript: hashValue, value: keyIndex  <a href="class_control_plane_othello.html#aac66f2ed68a4352423a2d73f320a6c39">More...</a><br /></td></tr>
<tr class="separator:aac66f2ed68a4352423a2d73f320a6c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe56fd8c4cfa26e24394dbf4e4d040c6"><td class="memItemLeft" align="right" valign="top"><a id="afe56fd8c4cfa26e24394dbf4e4d040c6"></a>
vector&lt; <a class="el" href="struct_othello_c_p_cell.html">OthelloCPCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#afe56fd8c4cfa26e24394dbf4e4d040c6">nextAtA</a> {}</td></tr>
<tr class="memdesc:afe56fd8c4cfa26e24394dbf4e4d040c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">subscript: keyIndex, value: keyIndex <br /></td></tr>
<tr class="separator:afe56fd8c4cfa26e24394dbf4e4d040c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22058a108b94c9adfd3e961bfabdc2c0"><td class="memItemLeft" align="right" valign="top"><a id="a22058a108b94c9adfd3e961bfabdc2c0"></a>
vector&lt; <a class="el" href="struct_othello_c_p_cell.html">OthelloCPCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nextAtB</b> {}</td></tr>
<tr class="separator:a22058a108b94c9adfd3e961bfabdc2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c998e7d42fe07d0f9747b2b78acfc9"><td class="memItemLeft" align="right" valign="top">DisjointSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#a06c998e7d42fe07d0f9747b2b78acfc9">connectivityForest</a></td></tr>
<tr class="memdesc:a06c998e7d42fe07d0f9747b2b78acfc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">h2(keys[i]) = h2(keys[next2[i]]);  <a href="class_control_plane_othello.html#a06c998e7d42fe07d0f9747b2b78acfc9">More...</a><br /></td></tr>
<tr class="separator:a06c998e7d42fe07d0f9747b2b78acfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:abe719ca231778366d03f91e27b440b35"><td class="memItemLeft" align="right" valign="top"><a id="abe719ca231778366d03f91e27b440b35"></a>
const static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_control_plane_othello.html#abe719ca231778366d03f91e27b440b35">MAX_REHASH</a> = 50</td></tr>
<tr class="memdesc:abe719ca231778366d03f91e27b440b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of rehash tries before report an error. If this limit is reached, Othello build fails. <br /></td></tr>
<tr class="separator:abe719ca231778366d03f91e27b440b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430d4266275b0bc961227f5a4d02d027"><td class="memItemLeft" align="right" valign="top"><a id="a430d4266275b0bc961227f5a4d02d027"></a>
const static int&#160;</td><td class="memItemRight" valign="bottom"><b>VDL</b> = L + DL</td></tr>
<tr class="separator:a430d4266275b0bc961227f5a4d02d027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8164acf06f30283cbb1f89cf8071e3"><td class="memItemLeft" align="right" valign="top"><a id="acc8164acf06f30283cbb1f89cf8071e3"></a>
const static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>VDEMASK</b> = ~(uint64_t(-1) &lt;&lt; VDL)</td></tr>
<tr class="separator:acc8164acf06f30283cbb1f89cf8071e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4b2c7fbcaea5c4b152c08a4484cb59"><td class="memItemLeft" align="right" valign="top"><a id="aed4b2c7fbcaea5c4b152c08a4484cb59"></a>
const static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>DEMASK</b> = ~(uint64_t(-1) &lt;&lt; DL)</td></tr>
<tr class="separator:aed4b2c7fbcaea5c4b152c08a4484cb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6569288ea11f240a4434bafb134ae4c2"><td class="memItemLeft" align="right" valign="top"><a id="a6569288ea11f240a4434bafb134ae4c2"></a>
const static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>VMASK</b> = ~(uint64_t(-1) &lt;&lt; L)</td></tr>
<tr class="separator:a6569288ea11f240a4434bafb134ae4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7a6cb45c090560e7632a39a01bc1d7"><td class="memItemLeft" align="right" valign="top"><a id="a1c7a6cb45c090560e7632a39a01bc1d7"></a>
const static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>VDMASK</b> = (VDEMASK &lt;&lt; 1) &amp; VDEMASK</td></tr>
<tr class="separator:a1c7a6cb45c090560e7632a39a01bc1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a57adcdcbb2c00da3e1d16cea07e20274"><td class="memTemplParams" colspan="2"><a id="a57adcdcbb2c00da3e1d16cea07e20274"></a>
template&lt;class K1 , class V1 , uint8_t L1, uint8_t DL1&gt; </td></tr>
<tr class="memitem:a57adcdcbb2c00da3e1d16cea07e20274"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DataPlaneOthello</b></td></tr>
<tr class="separator:a57adcdcbb2c00da3e1d16cea07e20274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4510df0cfb3141911ed358a681f3dfa"><td class="memTemplParams" colspan="2"><a id="af4510df0cfb3141911ed358a681f3dfa"></a>
template&lt;class K1 , bool l2, uint8_t DL1&gt; </td></tr>
<tr class="memitem:af4510df0cfb3141911ed358a681f3dfa"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OthelloFilterControlPlane</b></td></tr>
<tr class="separator:af4510df0cfb3141911ed358a681f3dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class K, class V, uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt;<br />
class ControlPlaneOthello&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;</h3>

<p>Control plane Othello can track connections (Add [amortized], Delete, Membership Judgment) in O(1) time, and can iterate on the keys in exactly n elements.</p>
<p>Implementation: just add an array indMem to be maintained. always ensure that registered keys can be queried to get the index of it in the keys array</p>
<p>How to ensure: add to tail when add, and store the value as well as the index to othello when delete, move key-value and update corresponding index</p>
<dl class="section note"><dt>Note</dt><dd>The valueType must be compatible with all int operations</dd></dl>
<p>If you wish to export the control plane to a data plane query structure at a fast speed and at any time, then set willExport to true. Additional computation and memory overheads will apply on insert, while lookups will be faster.</p>
<p>If you wish to maintain the disjoint set, the insertion will become faster but the deletion is slower, in the sense that memory accesses are more expensive than computation </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af90fc3b63bb599a7b6edab5f1753972a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90fc3b63bb599a7b6edab5f1753972a">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::addEdge </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>update the disjoint set and the connected forest so that include all the old keys and the newly inserted key </p><dl class="section note"><dt>Note</dt><dd>this method won't change the node value </dd></dl>

</div>
</div>
<a id="ab9afb6bba6c1b6ad17fdb53577bf4f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9afb6bba6c1b6ad17fdb53577bf4f0b">&#9670;&nbsp;</a></span>build()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::build </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>try really hard to build, until success or tryCount &gt;= MAX_REHASH</p>
<p>Side effect: 1) discard all memory except keys and values. 2) build fail, or all the values and disjoint set are properly set </p>

</div>
</div>
<a id="a58cd82573a97b86005611adbe55e07da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cd82573a97b86005611adbe55e07da">&#9670;&nbsp;</a></span>connectBFS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::connectBFS </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure the disjoint set is properly maintained after the construction. the workflow is: mark the representatives of all connected nodes as root </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6630b78c1477e02e02576b6dbfcf9a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6630b78c1477e02e02576b6dbfcf9a42">&#9670;&nbsp;</a></span>eraseAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::eraseAt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>keyId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>remove one key with the particular index keyId. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint32_t</td><td>keyId. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>after this option, the number of keys, keyCnt decrease by 1. The key currently stored in keys[keyId] will be replaced by the last key of keys. </dd>
<dd>
remember to adjust the values array if necessary. </dd></dl>

</div>
</div>
<a id="adc4fcb321e1d4efedde64ff7c95f1ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4fcb321e1d4efedde64ff7c95f1ce5">&#9670;&nbsp;</a></span>fillTreeDFS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<div class="memtemplate">
template&lt;bool fillValue, bool fillIndex, bool keepDigest = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::fillTreeDFS </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill the values of a connected tree starting at the root node and avoid searching keyId Assume:</p><ol type="1">
<li>the value of root is properly set before the function call</li>
<li>the values are in the value array</li>
<li>the root is always from array A Side effect: all node in this tree is set and if updateToFilled </li>
</ol>

</div>
</div>
<a id="af59f02d3a8f74a3dab8c5dd163216c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59f02d3a8f74a3dab8c5dd163216c63">&#9670;&nbsp;</a></span>fillValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<div class="memtemplate">
template&lt;bool keepDigest = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::fillValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill <em>Othello</em> so that the query returns values as defined</p>
<p>Assume: edges and disjoint set are properly set up. Side effect: all values are properly set </p>

</div>
</div>
<a id="aa2b988d0c4624715d39a6f8fd7ec163d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b988d0c4624715d39a6f8fd7ec163d">&#9670;&nbsp;</a></span>fixHalfTreeDFS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<div class="memtemplate">
template&lt;bool fillValue, bool fillIndex, bool keepDigest = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::fixHalfTreeDFS </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>keyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fix the values of a connected tree starting at the root node and avoid searching keyId Assume:</p><ol type="1">
<li>the value of root is not properly set before the function call</li>
<li>the values are in the value array</li>
<li>the root is always from array A Side effect: all node in this tree is set and if updateToFilled <dl class="section return"><dt>Returns</dt><dd>the xor template: &gt; 0 starting from the A node &lt; 0 from the B node == 0 doesn't matter </dd></dl>
</li>
</ol>

</div>
</div>
<a id="a6ab2413a6ac439467063026c5859d7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab2413a6ac439467063026c5859d7cd">&#9670;&nbsp;</a></span>fixSingle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<div class="memtemplate">
template&lt;bool fillValue, bool fillIndex, bool keepDigest = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::fixSingle </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nodeToFix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>fix the value and index at single node by xoring x </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the xor'ed number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b609c0bfae957af25237cbcab3cf1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b609c0bfae957af25237cbcab3cf1bf">&#9670;&nbsp;</a></span>getIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::getIndices </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aInd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>bInd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td></td></tr>
    <tr><td class="paramname">aInd,bInd</td><td>return indices of k into array A&amp;B </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88d8bfd7bf8ab2e13baf7986dc6a4769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d8bfd7bf8ab2e13baf7986dc6a4769">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<div class="memtemplate">
template&lt;bool DoNotRebuild = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">pair&lt; K, V &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>kv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert a key-value pair </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kv</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cyclic add: 1 &lt;&lt; VDL acyclic add: the xor template: &gt; 0 starting from the A node &lt; 0 from the B node == 0 doesn't matter </dd></dl>

</div>
</div>
<a id="aff99f09fe9c7eba6dc8a3ebc6a5294cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff99f09fe9c7eba6dc8a3ebc6a5294cd">&#9670;&nbsp;</a></span>isConnectedDFS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::isConnectedDFS </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ha0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hb0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>test the two nodes are connected or not Assume the Othello is properly built </p><dl class="section note"><dt>Note</dt><dd>cannot use disjoint set if because disjoint set cannot maintain valid after key deletion. So a traverse is performed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ha0</td><td></td></tr>
    <tr><td class="paramname">hb0</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if connected </dd></dl>

</div>
</div>
<a id="a492f6423114cf3eac94c9e7c58c1f6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492f6423114cf3eac94c9e7c58c1f6f5">&#9670;&nbsp;</a></span>memGet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::memGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in array A or array B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index-th element. if the index &gt; ma, it is the (index - ma)-th element in array B </dd></dl>

</div>
</div>
<a id="adec591e48d4d2bae9408fb5f11736320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec591e48d4d2bae9408fb5f11736320">&#9670;&nbsp;</a></span>memResize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::memResize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of uint64_t elements to hold ma + mb valueType elements </dd></dl>

</div>
</div>
<a id="aea9bf4ab36c087072d6546db2d796a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9bf4ab36c087072d6546db2d796a5a">&#9670;&nbsp;</a></span>memSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::memSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the index-th element to be value. if the index &gt; ma, it is the (index - ma)-th element in array B </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in array A or array B </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa7383a313da57dda4bb7ead9a46cc40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7383a313da57dda4bb7ead9a46cc40">&#9670;&nbsp;</a></span>query()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::query </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td></td></tr>
    <tr><td class="paramname">v</td><td>the lookup value for k </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lookup action is successful, but it does not mean the key is really a member </dd></dl>
<dl class="section note"><dt>Note</dt><dd>No membership is checked. Use isMember to check the membership </dd></dl>

</div>
</div>
<a id="aeb814a60b551f256f86f6aca894cd924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb814a60b551f256f86f6aca894cd924">&#9670;&nbsp;</a></span>queryIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::queryIndex </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of k in the array of keys </dd></dl>

</div>
</div>
<a id="a8b2e5da3c5dcd3fdaceb5653435ef105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2e5da3c5dcd3fdaceb5653435ef105">&#9670;&nbsp;</a></span>resizeKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::resizeKey </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>targetCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resize key and value related memory for the Othello to be able to hold keyCount keys </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetCapacity</td><td>the target capacity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Side effect: will change keyCnt, and if hash size is changed, a rebuild is performed </dd></dl>

</div>
</div>
<a id="a7d494ff4312346693f1bc4fe16c05fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d494ff4312346693f1bc4fe16c05fd8">&#9670;&nbsp;</a></span>testHash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::testHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>test if this hash pair is acyclic, and build: the connected forest and the disjoint set of connected relation the disjoint set will be only useful to determine the root of a connected component</p>
<p>Assume: all build related memory are cleared before Side effect: the disjoint set and the connected forest are changed </p>

</div>
</div>
<a id="af8947acec7f8a3e4d5e259a88297f3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8947acec7f8a3e4d5e259a88297f3da">&#9670;&nbsp;</a></span>tryBuild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::tryBuild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin a new build Side effect: 1) discard all memory except keys and values. 2) build fail, or all the values and disjoint set are properly set </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a06c998e7d42fe07d0f9747b2b78acfc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c998e7d42fe07d0f9747b2b78acfc9">&#9670;&nbsp;</a></span>connectivityForest</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DisjointSet <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::connectivityForest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>h2(keys[i]) = h2(keys[next2[i]]); </p>
<p>store the hash values that are connected by key edges </p>

</div>
</div>
<a id="aac66f2ed68a4352423a2d73f320a6c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac66f2ed68a4352423a2d73f320a6c39">&#9670;&nbsp;</a></span>head</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , uint8_t L = sizeof(V) * 8, uint8_t DL = 0, bool maintainDP = true, bool maintainDisjointSet = true, bool randomized = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="struct_othello_c_p_cell.html">OthelloCPCell</a>&gt; <a class="el" href="class_control_plane_othello.html">ControlPlaneOthello</a>&lt; K, V, L, DL, maintainDP, maintainDisjointSet, randomized &gt;::head {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>subscript: hashValue, value: keyIndex </p>
<p>multiple keys may share a same end (hash value) first and next1, next2 maintain linked lists, each containing all keys with the same hash in either of their ends </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/platform/<a class="el" href="control__plane__othello_8h_source.html">control_plane_othello.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
